// Integration tests for the LOBSTER dataset ingestion outputs.
//
// Purpose
// -------
// Validate that streams generated by `examples/ingest_lobster.rs` can be read
// end-to-end via the zero-copy `StreamReader::process_all` API, and that the
// FlatBuffers payloads can be deserialized using the checked-in generated code.
//
// Scope
// -----
// - Discovers and tests ALL generated `*-message.bin` and `*-orderbook.bin`
//   files in `tests/corpus/lobster/` (one pair per ZIP ingested).
// - Asserts each stream contains at least one message.
// - Deserializes payloads using the LOBSTER schemas:
//   * Message: (time in seconds [f64], type, order_id, size, price x10000, direction)
//   * Orderbook: vectors of Level{price x10000, size} for asks and bids
// - Timestamps: For orderbook snapshots, the k-th row inherits the time from
//   the k-th message row (native LOBSTER pairing; orderbook rows have no time).
//
// Notes
// -----
// - This test intentionally avoids pinning a specific symbol/date so that all
//   ingested corpora are validated.
// - Payload access remains zero-copy: `payload` is a borrowed `&[u8]` slice.
// - The LOBSTER FlatBuffers bindings are checked in for reproducibility.

use flatstream::{DefaultDeframer, StreamReader};
use std::fs::{self, File};
use std::io::BufReader;
use std::path::PathBuf;

mod lobster_generated {
    mod lobster_message_generated {
        #![allow(unused_imports)]
        #![allow(dead_code)]
        include!(concat!(
            env!("CARGO_MANIFEST_DIR"),
            "/examples/generated/lobster_message_generated.rs"
        ));
    }
    mod lobster_orderbook_generated {
        #![allow(unused_imports)]
        #![allow(dead_code)]
        include!(concat!(
            env!("CARGO_MANIFEST_DIR"),
            "/examples/generated/lobster_orderbook_generated.rs"
        ));
    }
    pub mod message {
        pub use super::lobster_message_generated::flatstream::lobster::*;
    }
    pub mod orderbook {
        pub use super::lobster_orderbook_generated::flatstream::lobster::*;
    }
}

#[test]
fn test_lobster_message_stream_reads() -> flatstream::Result<()> {
    let paths = list_with_suffix("tests/corpus/lobster", "-message.bin")
        .expect("Run `cargo run --example ingest_lobster --release` first");
    assert!(!paths.is_empty(), "no message streams found");
    for p in paths {
        let file = File::open(&p).unwrap_or_else(|_| panic!("missing file: {}", p.display()));
        let mut reader = StreamReader::new(BufReader::new(file), DefaultDeframer);
        let mut count = 0usize;
        reader.process_all(|payload| {
            let _ev = lobster_generated::message::root_as_message_event(payload).unwrap();
            count += 1;
            Ok(())
        })?;
        assert!(count > 0, "empty stream: {}", p.display());
    }
    Ok(())
}

#[test]
fn test_lobster_orderbook_stream_reads() -> flatstream::Result<()> {
    let paths = list_with_suffix("tests/corpus/lobster", "-orderbook.bin")
        .expect("Run `cargo run --example ingest_lobster --release` first");
    assert!(!paths.is_empty(), "no orderbook streams found");
    for p in paths {
        let file = File::open(&p).unwrap_or_else(|_| panic!("missing file: {}", p.display()));
        let mut reader = StreamReader::new(BufReader::new(file), DefaultDeframer);
        let mut count = 0usize;
        reader.process_all(|payload| {
            let _snap = lobster_generated::orderbook::root_as_order_book_snapshot(payload).unwrap();
            count += 1;
            Ok(())
        })?;
        assert!(count > 0, "empty stream: {}", p.display());
    }
    Ok(())
}

fn list_with_suffix(dir: &str, suffix: &str) -> Option<Vec<PathBuf>> {
    let mut entries: Vec<PathBuf> = fs::read_dir(dir)
        .ok()?
        .filter_map(|e| e.ok().map(|e| e.path()))
        .collect();
    entries.sort();
    Some(
        entries
            .into_iter()
            .filter(|p| p.is_file() && p.to_string_lossy().ends_with(suffix))
            .collect(),
    )
}
