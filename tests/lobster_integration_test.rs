#![cfg(feature = "lobster")]
// Integration tests for the LOBSTER dataset ingestion outputs.
//
// Purpose
// -------
// Validate that streams generated by `examples/ingest_lobster.rs` can be read
// end-to-end via the zero-copy `StreamReader::process_all` API, and that the
// FlatBuffers payloads can be deserialized using the checked-in generated code.
//
// Scope
// -----
// - Discovers and tests ALL generated `*-message.bin` and `*-orderbook.bin`
//   files in `tests/corpus/lobster/` (one pair per ZIP ingested).
// - Asserts each stream contains at least one message.
// - Deserializes payloads using the LOBSTER schemas:
//   * Message: (time in seconds [f64], type, order_id, size, price x10000, direction)
//   * Orderbook: vectors of Level{price x10000, size} for asks and bids
// - Timestamps: For orderbook snapshots, the k-th row inherits the time from
//   the k-th message row (native LOBSTER pairing; orderbook rows have no time).
//
// Notes
// -----
// - This test intentionally avoids pinning a specific symbol/date so that all
//   ingested corpora are validated.
// - Payload access remains zero-copy: `payload` is a borrowed `&[u8]` slice.
// - The LOBSTER FlatBuffers bindings are checked in for reproducibility.

use flatstream::{DefaultDeframer, StreamReader};
use std::fs::File;
use std::io::BufReader;

mod lobster_generated {
    mod lobster_message_generated {
        #![allow(unused_imports)]
        #![allow(dead_code)]
        #![allow(mismatched_lifetime_syntaxes)]
        #![allow(clippy::extra_unused_lifetimes)]
        #![allow(clippy::derivable_impls)]
        include!(concat!(
            env!("CARGO_MANIFEST_DIR"),
            "/examples/generated/lobster_message_generated.rs"
        ));
    }
    mod lobster_orderbook_generated {
        #![allow(unused_imports)]
        #![allow(dead_code)]
        #![allow(mismatched_lifetime_syntaxes)]
        #![allow(clippy::extra_unused_lifetimes)]
        #![allow(clippy::derivable_impls)]
        include!(concat!(
            env!("CARGO_MANIFEST_DIR"),
            "/examples/generated/lobster_orderbook_generated.rs"
        ));
    }
    pub mod message {
        pub use super::lobster_message_generated::flatstream::lobster::*;
    }
    pub mod orderbook {
        pub use super::lobster_orderbook_generated::flatstream::lobster::*;
    }
}

#[path = "harness/lobster_common.rs"]
mod lobster_common;

#[test]
fn test_lobster_message_stream_reads() -> flatstream::Result<()> {
    let root = "tests/corpus/lobster";
    let file_bases = lobster_common::find_verified_zip_file_bases(
        "tests/corpus/lobster/zips",
        "tests/corpus/lobster/zips/SHASUMS.txt",
    );
    if file_bases.is_empty() {
        panic!("No verified LOBSTER ZIPs. Download files listed in SHASUMS.txt, place in zips/, then run ingest.");
    }
    for base in file_bases {
        let p = std::path::Path::new(root).join(format!("{}-message.bin", base));
        if !p.exists() {
            continue;
        }
        let file = File::open(&p).unwrap_or_else(|_| panic!("missing file: {}", p.display()));
        let mut reader = StreamReader::new(BufReader::new(file), DefaultDeframer);
        let mut count = 0usize;
        reader.process_all(|payload| {
            let _ev = lobster_generated::message::root_as_message_event(payload).unwrap();
            count += 1;
            Ok(())
        })?;
        assert!(count > 0, "empty stream: {}", p.display());
    }
    Ok(())
}

#[test]
fn test_lobster_orderbook_stream_reads() -> flatstream::Result<()> {
    let root = "tests/corpus/lobster";
    let file_bases = lobster_common::find_verified_zip_file_bases(
        "tests/corpus/lobster/zips",
        "tests/corpus/lobster/zips/SHASUMS.txt",
    );
    if file_bases.is_empty() {
        panic!("No verified LOBSTER ZIPs. Download files listed in SHASUMS.txt, place in zips/, then run ingest.");
    }
    for base in file_bases {
        let p = std::path::Path::new(root).join(format!("{}-orderbook.bin", base));
        if !p.exists() {
            continue;
        }
        let file = File::open(&p).unwrap_or_else(|_| panic!("missing file: {}", p.display()));
        let mut reader = StreamReader::new(BufReader::new(file), DefaultDeframer);
        let mut count = 0usize;
        reader.process_all(|payload| {
            let _snap = lobster_generated::orderbook::root_as_order_book_snapshot(payload).unwrap();
            count += 1;
            Ok(())
        })?;
        assert!(count > 0, "empty stream: {}", p.display());
    }
    Ok(())
}
